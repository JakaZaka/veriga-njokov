package repositories

import models.*
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import java.util.UUID
import kotlin.random.Random

class DataRepository {
    // State flows for reactive UI
    private val _clothingItems = MutableStateFlow<List<ClothingItem>>(emptyList())
    val clothingItems: StateFlow<List<ClothingItem>> = _clothingItems.asStateFlow()
    
    private val _clothingStores = MutableStateFlow<List<ClothingStore>>(emptyList())
    val clothingStores: StateFlow<List<ClothingStore>> = _clothingStores.asStateFlow()
    
    private val _outfits = MutableStateFlow<List<Outfit>>(emptyList())
    val outfits: StateFlow<List<Outfit>> = _outfits.asStateFlow()
    
    private val _weatherData = MutableStateFlow<List<Weather>>(emptyList())
    val weatherData: StateFlow<List<Weather>> = _weatherData.asStateFlow()
    
    // CRUD operations
    fun addClothingItem(item: ClothingItem) {
        val newItem = item.copy(id = UUID.randomUUID().toString())
        _clothingItems.value = _clothingItems.value + newItem
    }
    
    fun updateClothingItem(updatedItem: ClothingItem) {
        _clothingItems.value = _clothingItems.value.map { 
            if (it.id == updatedItem.id) updatedItem else it 
        }
    }
    
    fun deleteClothingItem(itemId: String) {
        _clothingItems.value = _clothingItems.value.filter { it.id != itemId }
    }
    
    fun addOutfit(outfit: Outfit) {
        val newOutfit = outfit.copy(id = UUID.randomUUID().toString())
        _outfits.value = _outfits.value + newOutfit
    }
    
    fun deleteOutfit(outfitId: String) {
        _outfits.value = _outfits.value.filter { it.id != outfitId }
    }
    
    // Dummy data generation
    fun generateDummyClothingItems(count: Int) {
        val categories = ClothingCategory.values()
        val seasons = Season.values()
        val dummyItems = (1..count).map { index ->
            val randomSeason = seasons.random()
            ClothingItem(
                id = UUID.randomUUID().toString(),
                name = "Sample Item $index",
                category = categories.random(), // Use ClothingCategory enum
                subCategory = "Sample subcategory",
                color = listOf("Red", "Blue", "Green", "Black", "White").random(),
                size = listOf("XS", "S", "M", "L", "XL").random(),
                season = listOf(randomSeason), // Use List<Season>
                userId = "system", // Use userId parameter
                notes = "Sample item generated by system"
            )
        }
        _clothingItems.value = _clothingItems.value + dummyItems
    }
    
    fun generateDummyWeatherData(count: Int) {
        val locations = listOf("Ljubljana", "Maribor", "Celje", "Kranj")
        val dummyWeather = (1..count).map {
            Weather(
                id = UUID.randomUUID().toString(),
                location = locations.random(),
                temperature = Random.nextDouble(-10.0, 35.0),
                isRaining = Random.nextInt(1, 11) > 7, // 30% chance of rain
                isSnowing = Random.nextInt(1, 11) > 9, // 10% chance of snow
                fetchedAt = System.currentTimeMillis() - Random.nextLong(0, 86400000L) // Random time in last 24h
            )
        }
        _weatherData.value = _weatherData.value + dummyWeather
    }
    
    fun clearAllData() {
        _clothingItems.value = emptyList()
        _clothingStores.value = emptyList()
        _outfits.value = emptyList()
        _weatherData.value = emptyList()
    }
    
    // Fix function for weather recommendations
    fun getClothingRecommendations(location: String): ClothingRecommendations? {
        val weather = _weatherData.value
            .filter { it.location.equals(location, ignoreCase = true) }
            .maxByOrNull { it.fetchedAt ?: 0L } ?: return null

        val recommendedSeasonString = when {
            weather.temperature < 5.0 -> Season.WINTER.name
            weather.temperature < 15.0 -> Season.FALL.name
            weather.temperature < 25.0 -> Season.SPRING.name
            else -> Season.SUMMER.name
        }

        val recommendedItems = _clothingItems.value.filter { clothing ->
            clothing.season.any { seasonEnum ->
                seasonEnum.name.equals(recommendedSeasonString, ignoreCase = true) ||
                seasonEnum.displayName.equals(recommendedSeasonString, ignoreCase = true) ||
                seasonEnum == Season.ALL
            }
        }

        val weatherMessage = when {
            weather.isRaining && weather.isSnowing -> "It's raining and snowing. Stay warm and dry!"
            weather.isRaining -> "It's raining. Don't forget a waterproof jacket!"
            weather.isSnowing -> "It's snowing. Wear warm, waterproof clothing!"
            weather.temperature < 5.0 -> "It's very cold. Wear warm layers!"
            weather.temperature < 15.0 -> "It's cool outside. Consider a jacket."
            weather.temperature < 25.0 -> "Pleasant temperature. Light layers recommended."
            else -> "It's warm! Dress lightly."
        }

        return ClothingRecommendations(
            weather = weather,
            recommendedItems = recommendedItems,
            weatherMessage = weatherMessage
        )
    }
    
    // Updated filter method to match the real model
    fun filterClothingItems(
        category: String? = null,
        season: String? = null,
        favorite: Boolean? = null
    ): List<ClothingItem> {
        return _clothingItems.value.filter { item ->
            (category == null || item.category.name.equals(category, ignoreCase = true) || item.category.displayName.equals(category, ignoreCase = true)) &&
            (season == null || item.season.any { it.name.equals(season, ignoreCase = true) || it.displayName.equals(season, ignoreCase = true) }) &&
            (favorite == null || item.liked == favorite) // Assuming 'favorite' maps to 'liked'
        }
    }
}

// This class should remain outside the main class
data class ClothingRecommendations(
    val weather: Weather,
    val recommendedItems: List<ClothingItem>,
    val weatherMessage: String
)